---
layout: page
excerpt: diff diff diff
---

## TODO:

* [x] How heinous will it be to get the edges in the SVG to have useful ids?
    * [It's easy!](https://graphviz.org/docs/outputs/#ID)
* [x] Write a `shell` Liquid tag for Jekyll that exec's in the file's directory
    * Use it to produce diffing graphs: {% raw %}`{% shell generate_graph.rb ABCAB CBABA %}`{% endraw %}
* [ ] Write animation code driven by the above collections of edge ids
    * resist the temptation to let readers customize their diffs by switching to a JS graphviz and bespoke diffing toolchain
* [ ] Write diffing animations scripts for:
    * [x] Breadth-first ABCAB v CBABA
    * [ ] Greedy Best First Search ABCAB v CBABA
    * [ ] Myers ABCAB v CBABA
    * [ ] Myers meet-in-the-middle ABCAB v CBABA

Post plan
* Diffing
    * Intro (introduce LCS)
    * Breadth-First
    * Greedy Breadth-First Search
    * Myers
    * Myers meet-in-the-middle
    * Worst Case
    * Historical Optimizations: What if you don't _need_ LCS? (Trading off Either Correctness or Degenerate Edge Performance)
        * heckel
        * Divide and Conquer: patience
    * New Frontiers
        * Membership testing
        * n-grams

* Future:
    * Membership testing
        * Membership PARTS v MIRTH
        * Membership-after PARTS v STRAP
    * Inexact diffing
        * limited-breadth Myers
        * arrow

## Animation Prototype

(click any of the elements below to start/stop)

<div id="foo">
  <p>Element 1</p>
  <p>Element 2</p>
  <p>Element 3</p>
</div>
<script>
    const foo = document.getElementById("foo");
    const elements = foo.getElementsByTagName("p");
    let index = 0;
    let intervalId = null;

    function changeColor() {
      if (index >= elements.length) {
        [...elements].map(function(e) { e.style.color = ""; })
        index = 0;
        return
      }
      elements[index].style.color = "blue";
      index++;
    }

    foo.addEventListener("click", function() {
      if (intervalId) {
        clearInterval(intervalId);
        intervalId = null;
      } else {
        intervalId = setInterval(changeColor, 1000);
      }
    });
</script>

## Graphs

{% capture gitsha %}{% shell git rev-parse HEAD %}{% endcapture %}
DOT generated by [`generate_graph.rb`](https://github.com/numist/numi.st/tree/{{ gitsha | strip }}/_posts/2023-03-18-diffing/generate_graph.rb), rendered by [a Jekyll graphviz plugin]({% post_url 2023-03-17-graphviz %})

### Breadth-First Search

The naive way to solve this problem is by traversing the graph breadth-first until the corners are connected by a line.

{% graphviz %}{% shell ./generate_graph.rb ABCAB CBABA "Breadth-First Search" %}{% endgraphviz %}

``` javascript
// Edge animation steps for breadth-first search
const bfs_steps = ["0_0to1_0", "0_0to0_1", "1_0to2_0", "1_0to1_1", "0_1to0_2", "2_0to3_0", "2_0to3_1", "2_0to2_1", "1_1to2_2", "1_1to1_2", "0_2to1_3", "0_2to0_3", "3_0to4_0", "3_1to4_1", "3_1to3_2", "2_2to2_3", "1_3to2_4", "1_3to1_4", "0_3to0_4", "4_0to5_0", "4_1to5_1", "4_1to5_2", "4_1to4_2", "3_2to4_3", "3_2to3_3", "2_4to3_4", "2_4to2_5", "1_4to1_5", "0_4to0_5", "5_2to5_3", "4_3to5_4", "4_3to4_4", "3_4to4_5", "3_4to3_5", "5_4to5_5"]
```

### Greedy Breadth-First

If you're familiar with graph theory, you'll recognize this as a shortest path problem. Sure enough, the next most efficient way to solve it is by giving each horizontal and vertical edge some cost (diagonals are free) and running Dijkstra's algorithm (or in this case, a greedy breadth-first search, since it's easier to animate)

{% graphviz %}{% shell ./generate_graph.rb ABCAB CBABA "Greedy Breadth-First" %}{% endgraphviz %}

### Myers

The person who first recognized diffing as a graph problem[^obvious] also realized that "2 deletes and 2 inserts" may represent up to four different paths and an optimal algorithm only needs to follow the one making the most progress, resulting in an algorithm that abandons paths that aren't making progress.

[^obvious]: When I asked him about it, Gene told me graph representation "seemed rather obvious" but I'd still argue that seeming inevitable in retrospect is a hallmark of good design

{% graphviz %}{% shell ./generate_graph.rb ABCAB CBABA Myers %}{% endgraphviz %}

<!--
1 delete, 0 insert
1 insert, 0 delete
2 delete, 0 insert
1 delete, 1 insert
0 delete, 2 insert
3 delete, 0 insert
2 delete, 1 insert
1 delete, 2 insert
0 delete, 3 insert
4 delete, 0 insert
3 delete, 1 insert
2 delete, 2 insert
solved!?
1 delete, 3 insert
0 delete, 4 insert
-->

#### Myers' "Middle Snake"

{% graphviz %}{% shell ./generate_graph.rb ABCAB CBABA "Myers Meet-in-the-Middle" %}{% endgraphviz %}

### Membership Testing

{% graphviz %}{% shell ./generate_graph.rb PARTS MIRTH "Membership Testing Example" %}{% endgraphviz %}

### Worst Case (back to O(nÂ²))

{% graphviz %}{% shell ./generate_graph.rb PARTS STRAP "Worst Case" %}{% endgraphviz %}
