---
layout: page
excerpt: diff diff diff
---

## TODO:

* [x] How heinous will it be to get the edges in the SVG to have useful ids?
    * [It's easy!](https://graphviz.org/docs/outputs/#ID)
* [x] Write a `shell` Liquid tag for Jekyll that exec's in the file's directory
    * Use it to produce diffing graphs: {% raw %}`{% shell generate_graph.rb ABCAB CBABA %}`{% endraw %}
* [ ] Write animation code driven by the above collections of edge ids
    * resist the temptation to let readers customize their diffs by switching to a JS graphviz and bespoke diffing toolchain
* [ ] Write diffing animations scripts for:
    * [x] Breadth-first ABCAB v CBABA
    * [ ] Greedy Best First Search ABCAB v CBABA
    * [ ] Myers ABCAB v CBABA
    * [ ] Myers meet-in-the-middle ABCAB v CBABA

Post plan
* Diffing
    * Intro (introduce LCS)
    * Breadth-First
    * Greedy Breadth-First Search
    * Myers
    * Myers meet-in-the-middle
    * Worst Case
    * Historical Optimizations: What if you don't _need_ LCS? (Trading off Either Correctness or Degenerate Edge Performance)
        * heckel
        * Divide and Conquer: patience
    * New Frontiers
        * Membership testing
        * n-grams

* Future:
    * Membership testing
        * Membership PARTS v MIRTH
        * Membership-after PARTS v STRAP
    * Inexact diffing
        * limited-breadth Myers
        * arrow

## Animation Prototype

(click the grapth below to start/stop)

{% graphviz testbfs %}{% shell ./generate_graph.rb ABCAB CBABA "Breadth-First Search" %}{% endgraphviz %}

<script>
    const svg_name = "testbfs"
    const bfs_steps = ["0_0to1_0", "0_0to0_1", "1_0to2_0", "1_0to1_1", "0_1to0_2", "2_0to3_0", "2_0to3_1", "2_0to2_1", "1_1to2_2", "1_1to1_2", "0_2to1_3", "0_2to0_3", "3_0to4_0", "3_1to4_1", "3_1to3_2", "2_2to2_3", "1_3to2_4", "1_3to1_4", "0_3to0_4", "4_0to5_0", "4_1to5_1", "4_1to5_2", "4_1to4_2", "3_2to4_3", "3_2to3_3", "2_4to3_4", "2_4to2_5", "1_4to1_5", "0_4to0_5", "5_2to5_3", "4_3to5_4", "4_3to4_4", "3_4to4_5", "3_4to3_5", "5_4to5_5"]

    const foo = document.getElementById(`${svg_name}`);
    let index = 0;
    let intervalId = null;
    foo.querySelector(`g.node#progress text`).textContent = `${index}/${bfs_steps.length}`;

    function changeColor() {
      if (index >= bfs_steps.length) {
        // change the stroke color of all the path elements in the svg with id = `svg_name` to "#ddd"
        document.getElementById(`${svg_name}`).querySelectorAll("path").forEach(function(e) { e.setAttribute("stroke", "#ddd"); });
        index = 0;
        foo.querySelector(`g.node#progress text`).textContent = `0/${bfs_steps.length}`;
        return
      }
      // log to the console
      console.log(`Changing color of edge_${bfs_steps[index]}`);
      
      // change the stroke color of the path element inside the g tag with id = `bfs_steps[index]` in the svg with id = `svg_name` to #000
      foo.querySelector(`g.edge#edge_${bfs_steps[index]} path`).setAttribute("stroke", "#000");

      // change the value of the counter to `index`/`bfs_steps.length`
      foo.querySelector(`g.node#progress text`).textContent = `${index + 1}/${bfs_steps.length}`;

      index++;
    }

    foo.addEventListener("click", function() {
      if (intervalId) {
        clearInterval(intervalId);
        intervalId = null;
      } else {
        intervalId = setInterval(changeColor, 100);
      }
    });
</script>

## Graphs

{% capture gitsha %}{% shell git rev-parse HEAD %}{% endcapture %}
DOT generated by [`generate_graph.rb`](https://github.com/numist/numi.st/tree/{{ gitsha | strip }}/_posts/2023-03-18-diffing/generate_graph.rb), rendered by [a Jekyll graphviz plugin]({% post_url 2023-03-17-graphviz %})

### Breadth-First Search

The naive way to solve this problem is by traversing the graph breadth-first until the corners are connected by a line.

{% graphviz %}{% shell ./generate_graph.rb ABCAB CBABA "Breadth-First Search" %}{% endgraphviz %}

``` javascript
// Edge animation steps for breadth-first search
const bfs_steps = ["0_0to1_0", "0_0to0_1", "1_0to2_0", "1_0to1_1", "0_1to0_2", "2_0to3_0", "2_0to3_1", "2_0to2_1", "1_1to2_2", "1_1to1_2", "0_2to1_3", "0_2to0_3", "3_0to4_0", "3_1to4_1", "3_1to3_2", "2_2to2_3", "1_3to2_4", "1_3to1_4", "0_3to0_4", "4_0to5_0", "4_1to5_1", "4_1to5_2", "4_1to4_2", "3_2to4_3", "3_2to3_3", "2_4to3_4", "2_4to2_5", "1_4to1_5", "0_4to0_5", "5_2to5_3", "4_3to5_4", "4_3to4_4", "3_4to4_5", "3_4to3_5", "5_4to5_5"]
```

### Greedy Breadth-First

If you're familiar with graph theory, you'll recognize this as a shortest path problem. Sure enough, the next most efficient way to solve it is by giving each horizontal and vertical edge some cost (diagonals are free) and running Dijkstra's algorithm (or in this case, a greedy breadth-first search, since it's easier to animate)

{% graphviz %}{% shell ./generate_graph.rb ABCAB CBABA "Greedy Breadth-First" %}{% endgraphviz %}

``` javascript
// Edge animation steps for greedy breadth-first search
const bfs_steps = ["0_0to1_0", "0_0to0_1", "1_0to2_0", "1_0to1_1", "0_1to0_2", "2_0to3_0", "2_0to3_1", "3_1to4_1", "3_1to3_2", "2_0to2_1", "1_1to2_2", "2_2to2_3", "1_1to1_2", "0_2to1_3", "1_3to2_4", "2_4to3_4", "2_4to2_5", "1_3to1_4", "0_2to0_3", "3_0to4_0", "4_1to5_1", "4_1to5_2", "5_2to5_3", "4_1to4_2", "3_2to4_3", "4_3to5_4", "5_4to5_5"]
```

### Myers

The person who first recognized diffing as a graph problem[^obvious] also realized that "2 deletes and 2 inserts" may represent up to four different paths and an optimal algorithm only needs to follow the one making the most progress, resulting in an algorithm that abandons paths that aren't making progress.

[^obvious]: When I asked him about it, Gene told me graph representation "seemed rather obvious" but I'd still argue that seeming inevitable in retrospect is a hallmark of good design

{% graphviz %}{% shell ./generate_graph.rb ABCAB CBABA Myers %}{% endgraphviz %}

``` javascript
// Edge animation steps for greedy breadth-first search
const bfs_steps = ["0_0to1_0", "0_0to0_1", "1_0to2_0", "1_0to1_1", "0_1to0_2", "2_0to3_1", "3_1to4_1", "3_1to3_2", "1_1to2_2", "2_2to2_3" /* undone by 2_4to3_4 */, "0_2to1_3", "1_3to2_4", "2_4to3_4", "2_4to2_5", "4_1to5_2", "5_2to5_3", "3_2to4_3", "4_3to5_4", "5_4to5_5"]
```

#### Myers' "Middle Snake"

{% graphviz %}{% shell ./generate_graph.rb ABCAB CBABA "Myers Meet-in-the-Middle" %}{% endgraphviz %}

### Membership Testing

{% graphviz %}{% shell ./generate_graph.rb PARTS MIRTH "Membership Testing Example" %}{% endgraphviz %}

### Worst Case (back to O(nÂ²))

{% graphviz %}{% shell ./generate_graph.rb PARTS STRAP "Worst Case" %}{% endgraphviz %}
